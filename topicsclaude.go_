package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/google/generative-ai-go/genai"
	"google.golang.org/api/option"
)

// Data structures matching your diagram
type Course struct {
	Title           string   `json:"title"`
	Color           string   `json:"color"`
	Icon            string   `json:"icon"`
	Lessons         []string `json:"lessons"`
	Level           string   `json:"level"`
	ExaminationBody string   `json:"examination_body"`
}

type Lesson struct {
	Icon          string   `json:"icon"`
	Title         string   `json:"title"`
	Description   string   `json:"description"`
	Content       string   `json:"content"`
	DeckIds       []string `json:"deck_ids"`     // References to flashcard decks
	QuizIds       []string `json:"quiz_ids"`     // References to quizzes
	Course        string   `json:"course"`
	Audio         string   `json:"audio,omitempty"`
	Concepts      []string `json:"concepts"`
	Order         int      `json:"order"`
	Prerequisites []string `json:"prerequisites"`
}

type Topic struct {
	Lesson string `json:"lesson"`
	Level  string `json:"level"`
}

type ProcessedData struct {
	Course Course  `json:"course"`
	Topics []Topic `json:"topics"`
}

func main() {
	apiKey := os.Getenv("GEMINI_API_KEY")
	if apiKey == "" {
		fmt.Println("âŒ Please set the GEMINI_API_KEY environment variable.")
		return
	}

	// Paths
	mdDir := "markdown"
	outDir := "topics"

	// Ensure directories exist
	if err := os.MkdirAll(outDir, 0755); err != nil {
		fmt.Printf("âŒ Failed to create topics directory: %v\n", err)
		return
	}

	ctx := context.Background()
	client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
	if err != nil {
		fmt.Printf("âŒ Failed to create Gemini client: %v\n", err)
		return
	}
	defer client.Close()

	model := client.GenerativeModel("gemini-1.5-flash")

	// Check if markdown directory exists
	if _, err := os.Stat(mdDir); os.IsNotExist(err) {
		fmt.Printf("âŒ Markdown directory '%s' does not exist\n", mdDir)
		return
	}

	// Walk through Markdown files
	files, err := ioutil.ReadDir(mdDir)
	if err != nil {
		fmt.Printf("âŒ Failed to read markdown directory: %v\n", err)
		return
	}

	if len(files) == 0 {
		fmt.Printf("âš ï¸  No files found in '%s' directory\n", mdDir)
		return
	}

	processedCount := 0
	skippedCount := 0

	for _, f := range files {
		if filepath.Ext(f.Name()) != ".md" {
			continue
		}

		mdPath := filepath.Join(mdDir, f.Name())
		jsonName := strings.TrimSuffix(f.Name(), ".md") + ".json"
		jsonPath := filepath.Join(outDir, jsonName)

		// Skip if already exists
		if _, err := os.Stat(jsonPath); err == nil {
			fmt.Printf("âœ… Skipping %s (already has JSON)\n", f.Name())
			skippedCount++
			continue
		}

		fmt.Printf("ðŸ”„ Processing %s...\n", f.Name())

		// Read Markdown
		content, err := ioutil.ReadFile(mdPath)
		if err != nil {
			fmt.Printf("âŒ Failed to read markdown file '%s': %v\n", f.Name(), err)
			continue
		}

		// Enhanced prompt with better structure and examples
		prompt := fmt.Sprintf(`You are a curriculum expert analyzing a syllabus in Markdown format. 

Extract and structure the information according to this schema:

COURSE INFORMATION:
- title: Main subject/course name
- color: Suggest a hex color code appropriate for the subject
- icon: Suggest an appropriate icon name (material design style)
- level: Educational level (e.g., "Form 5", "Grade 10", "A-Level")
- examination_body: The examining authority if mentioned
- lessons: Array of main topic/lesson titles

TOPICS/LESSONS:
For each topic/lesson identified, extract:
- lesson: The topic/lesson name
- level: The educational level for this specific topic

Return ONLY valid JSON in this exact format:
{
  "course": {
    "title": "Subject Name",
    "color": "#hexcode",
    "icon": "icon_name",
    "level": "Form 5",
    "examination_body": "Examining Body",
    "lessons": ["Topic 1", "Topic 2", "Topic 3"]
  },
  "topics": [
    { "lesson": "Topic 1", "level": "Form 5" },
    { "lesson": "Topic 2", "level": "Form 5" },
    { "lesson": "Topic 3", "level": "Form 6" }
  ]
}

Syllabus content:
%s`, string(content))

		// Send to Gemini with error handling
		resp, err := model.GenerateContent(ctx, genai.Text(prompt))
		if err != nil {
			fmt.Printf("âŒ Gemini API error for '%s': %v\n", f.Name(), err)
			continue
		}

		// Collect and clean response
		var out strings.Builder
		for _, cand := range resp.Candidates {
			if cand.Content == nil {
				continue
			}
			for _, part := range cand.Content.Parts {
				out.WriteString(fmt.Sprint(part))
			}
		}

		responseText := out.String()
		if responseText == "" {
			fmt.Printf("âŒ Empty response from Gemini for '%s'\n", f.Name())
			continue
		}

		// Clean and validate JSON response
		cleanedJSON := cleanJSONResponse(responseText)
		
		// Validate JSON structure
		var processedData ProcessedData
		if err := json.Unmarshal([]byte(cleanedJSON), &processedData); err != nil {
			fmt.Printf("âŒ Invalid JSON response for '%s': %v\n", f.Name(), err)
			fmt.Printf("Response was: %s\n", cleanedJSON)
			continue
		}

		// Write formatted JSON file
		formattedJSON, err := json.MarshalIndent(processedData, "", "  ")
		if err != nil {
			fmt.Printf("âŒ Failed to format JSON for '%s': %v\n", f.Name(), err)
			continue
		}

		if err := os.WriteFile(jsonPath, formattedJSON, 0644); err != nil {
			fmt.Printf("âŒ Failed to write JSON file '%s': %v\n", jsonName, err)
			continue
		}

		fmt.Printf("âœ… Saved %s (%d topics)\n", jsonName, len(processedData.Topics))
		processedCount++

		// Rate limiting to avoid hammering the API
		time.Sleep(3 * time.Second)
	}

	// Summary
	fmt.Println("\n" + strings.Repeat("=", 50))
	fmt.Printf("ðŸŽ‰ Processing complete!\n")
	fmt.Printf("ðŸ“Š Files processed: %d\n", processedCount)
	fmt.Printf("â­ï¸  Files skipped: %d\n", skippedCount)
	fmt.Printf("ðŸ“ Output directory: %s\n", outDir)
}

// cleanJSONResponse removes common formatting issues from AI responses
func cleanJSONResponse(response string) string {
	// Remove markdown code blocks
	re := regexp.MustCompile("```(?:json)?\n?(.*?)\n?```")
	matches := re.FindStringSubmatch(response)
	if len(matches) > 1 {
		response = matches[1]
	}

	// Trim whitespace
	response = strings.TrimSpace(response)

	// Remove any leading/trailing non-JSON content
	startIdx := strings.Index(response, "{")
	endIdx := strings.LastIndex(response, "}")
	
	if startIdx >= 0 && endIdx >= 0 && endIdx > startIdx {
		response = response[startIdx : endIdx+1]
	}

	return response
}

// Helper functions for future expansion

// validateCourseData ensures the course data has required fields
func validateCourseData(course Course) error {
	if course.Title == "" {
		return fmt.Errorf("course title is required")
	}
	if course.Level == "" {
		return fmt.Errorf("course level is required")
	}
	return nil
}

// generateLessonStructure creates lesson objects from topics (for future use)
func generateLessonStructure(lessons []Lesson, courseTitle string) []Lesson {
	// Post-process lessons to ensure consistency
	for i := range lessons {
		lessons[i].Course = courseTitle
		lessons[i].Order = i + 1
		
		// Ensure empty fields are properly set
		if lessons[i].Content == "" {
			lessons[i].Content = ""
		}
		if lessons[i].DeckIds == nil {
			lessons[i].DeckIds = []string{}
		}
		if lessons[i].QuizIds == nil {
			lessons[i].QuizIds = []string{}
		}
		if lessons[i].Audio == "" {
			lessons[i].Audio = ""
		}
		if lessons[i].Concepts == nil {
			lessons[i].Concepts = []string{}
		}
		if lessons[i].Prerequisites == nil {
			lessons[i].Prerequisites = []string{}
		}
	}
	
	return lessons
}
